use core {package, *}
use runtime
use otmp
use http
use http.server {Req :: Request, Res :: Response, route}
use core.encoding.json

#inject runtime.vars {
    Enable_Heap_Debug :: true
    Debug :: true
}

reg: otmp.TemplateRegistry;
#inject Res {
    render :: (r: &Res, template: str, vars: any) {
        s := reg->render_template(template, &r.writer, .{ vars.data, vars.type });

        if s != .None {
            log(.Warning, "Template Renderer", tprintf("{}", s));
        }

        r->status(200 if s == .None else 400);
        r->end();
    }
}

@route.{.GET, "/"}
(req: &Req, res: &Res) => res->render("pages/homepage", null);

@route.{.GET, "/ovmwasm"}
(req: &Req, res: &Res) => res->render("pages/ovmwasm", null);

@route.{.GET, "/docs"}
(req: &Req, res: &Res) => res->render("pages/docs", null);

@route.{.GET, "/docs/install"}
(req: &Req, res: &Res) => res->render("pages/docs/install", null);


Article :: struct { name, description, path, date: str }
news_articles: Cached_Resource([] Article);

@route.{.GET, "/news/:article"}
(req: &Req, res: &Res) {
    article := array.first(news_articles->get() ?? .[], #(it.path == req.url_params["article"]));
    if !article do return;

    filename := tprintf("www/news-articles/{}.html", article.path);

    if os.file_exists(filename) {
        contents := os.get_contents(filename);
        defer delete(&contents);

        res->render("pages/news_article", &.{
            article = .{ contents = contents, name = article.name }
        });

    } else {
        res->status(404);
    }
}

@route.{.GET, "/news"}
(req: &Req, res: &Res) {
    articles := news_articles->get() ?? .[];

    res->render("pages/news", &.{
        articles = articles
    });
}

main :: () {
    reg = otmp.registry();
    reg->load_directory("./www/templates", ".html");

    news_articles = .{
        resource = .{},
        max_age = 60 * 60, // 1 hour

        fetch_resource = () -> ? [] Article {
            article_file := os.get_contents("www/news-articles/index.json");
            article_index, json_err := json.decode_with_error(article_file);
            if json_err->has_error() {
                return .{};
            }

            articles: [] Article;
            #context_scope {
                context.allocator = alloc.heap_allocator;
                json.as_any(article_index.root, &articles);
            }
            return articles;
        },

        release_resource = (articles: &[] Article) {
            delete(articles, allocator=alloc.heap_allocator);
        }
    };

    app := http.server.application();

    http.server.set_mime_type("svg", "image/svg+xml");

    files := http.server.static("/static/", "./www/static/");
    app->pipe(&files);

    #if #defined(runtime.vars.Debug) {
        app->pipe((req, res) => {
            reg->refresh_templates();
        });
    }

    router := http.server.router();
    router->collect_routes();
    app->pipe(&router);

    app->pipe((req, res) => {
        if !res.completed {
            res->render("pages/404", null);
        }
    });

    logger := http.server.logger();
    app->pipe(&logger);

    app->serve(8081);
    println("Server stopping...");
}


