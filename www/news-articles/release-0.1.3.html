<h1>Beta Release 0.1.3</h1>

<p>
This release of Onyx brings a large change to the compile-time code blocks feature, runtime stack traces, as well as a massive speedup to Onyx's <code>ovmwasm</code> runtime. There are also numerous additions to the standard library.
</p>

<h2>Code blocks with captures</h2>
<p>
    Code blocks have always been a very powerful feature of Onyx, especially when combined with macros. Most of the <code>core.slice</code> library is builtin around using code blocks. However, they were always a little weird, as you had to use the name of the variable as it was prescribed by the procedure you were calling. Look at <code>core.slice.fold</code> as an example.
</p>

<pre class="hljs"><code class="language-onyx">// This is the old way of doing this.
arr := i32.[2, 3, 5, 7, 11];

total := core.slice.fold(arr, 0, #(it + acc));

println(total);
</code></pre>

<p>
When using <code>core.slice.fold</code>, you just had to know that it gave you two values: <code>it</code> for the current value, and <code>acc</code> for the accumulator.
</p>

<p>
Now, with the <em>new, required</em> syntax for code-blocks you can specify the names of these variables.
</p>

<pre class="hljs"><code class="language-onyx">// This is the new way of doing this.
arr := i32.[2, 3, 5, 7, 11];

total := core.slice.fold(arr, 0, [element, partial_total](element + partial_total));

println(total);
</code></pre>

<p>
This does require a syntax change, and hence is a <strong>breaking change</strong>.
However, this feature has not been used much in actual yet, so there shouldn't be much to change.
Also, there is no semantic difference between the previous way this worked and the current way.
The current way only allows for explicit bindings; this would also work in the new version.
</p>

<pre class="hljs"><code class="language-onyx">// This also works
arr := i32.[2, 3, 5, 7, 11];

total := core.slice.fold(arr, 0, [](it + acc));

println(total);
</code></pre>

<p>
Notice that no captures are given, and we can still access <code>it</code> and <code>acc</code> directly like before.
This may change in the future.
</p>

<p>
In order to capture values in this way, the corresponding <code>#unquote</code> must provide values in the following way.
</p>

<pre class="hljs"><code class="language-onyx">// How slice.fold is implemented
slice.fold :: macro (arr: [] $T, initial: $R, condition: Code) -> R {
    acc := initial;
    for arr {
        acc = #unquote condition(it, acc);
    }
    return acc;
}
</code></pre>

<p>
This is intended to look a lot like a function call, but the <code>#unquote</code> is still required to aid readability that this is a code-block being expanded.
</p>



<h2>Runtime stack traces</h2>

<p>
You can now ask for a stack trace at any point in your program, so long as you compile it with the <code>--stack-trace</code> option. Simply call <code>runtime.info.get_stack_trace</code>. The stack trace is allocated into the temporary allocator of the current context, so make sure you copy it if you want to store it for later.
</p>

<pre class="hljs"><code class="language-onyx">
print_stack_trace :: () {
    use runtime.info;

    trace := info.get_stack_trace();
    for trace {
        // `it.info` points to static data about the trace node, which contains:
        //     func_name - the function name
        //     file      - the file name
        //     line      - the line the function was defined on
        //     func_type - the type of the function
        //
        // `it.current_line` is the line the function is executing.
        //
        printf("{} ({}:{})", it.info.func_name, it.info.file, it.current_line);
    }
}

main :: () {
    print_stack_trace();
}
</code></pre>

<p>
This feature is already integrated into the standard library to print stack traces in useful places, such as in the logging allocator and on failed assertions. There are plans to make a remote memory debugger, so trace every allocation made in your program, which will use the stack trace to give you a better idea where the memory is getting allocated.
</p>

<p>
Note, at the time of writing, there is no way to enable the <code>--stack-trace</code> compiler flag on the <a href="https://onyxlang.io/playground">Onyx Playground</a>. This will be addressed soon.
</p>


<h2>OVM-Wasm compiler optimizations</h2>

<p>
OVM-Wasm, the WebAssembly runtime written for and used by Onyx was originally written as quickly as possible to get something to work. Then, it wasn't touched for about a year. It is understandably going to be slower than any native runtime, as it is an interpreter for a bytecode, not a native compiler. However, it still had plenty of room to speedup, as there were <em>absolutely zero</em> optimizations done to the generated bytecode. That changed in this update.
</p>

<p>
Thanks to performing <em><a href="https://en.wikipedia.org/wiki/Copy_propagation">copy propagation</a></em>, all unnecessary register copies were removed (there were a lot!), and the result was a <strong>1.4 times speedup, or 30 percent time reduction for most programs</strong>. I would like to say this was some heroic effort that took a lot of work, but it was one evening of thinking about the problem a little harder and realising that everything needed to perform copy propagation was already there. The diff was around 50 lines of code to implement the optimization. Either way, this was a huge performance win for OVM-Wasm.
</p>


<h2>Full Changelog</h2>
<pre>
Additions:
- New syntax for declaring quoted code blocks.
    - `[captures] { body }` for blocks.
    - `[captures] ( expr )` for expressions.
- User-level stack trace.
    - Enable with `--stack-trace`
    - Use `runtime.info.get_stack_trace()` to get the current stack trace.
    - Used in assertions and heap allocator for better error reporting
- `Optional.with` for running a block of code with the value in an Optional, if one is present.
- `-Dvariable=value` command line option to add symbols to the `runtime.vars` package.
- `--no-type-info` command line option to omit type information from the binary.
- `Allocator.move`. Moves a value into an allocator, returning a pointer to it.
    - This is a copy operation (and might be renamed later)
- `core.encoding.hex` package
    - Quickly convert a byte array to and from its hex equivalent.
- `os.path_clean`
- `os.path_directory`
- `os.path_extension`
- `os.path_split`
- `slice.equal`
- `iter.find`
- `iter.flatten`

Removals:
- Remove old syntax for quoted blocks, `#quote` and `#()`.
    - Switch to `[] {}` and `[] ()` respectively.
- Old WASI specific modules for time and environment variables.
- `Result.return_err` and `Result.return_ok`.
    - Unnecessary with new union features.

Changes:
- Much faster backend (approximate 1.3-1.4x speedup for most programs)
- Added support for optionals in `json.encode`, `json.from_any`, and `json.as_any`.
- Added support for optionals in `conv.parse_any`.
- `Set` implementation no longer contains a "default value". Instead, an optional is returned from `get`.
    - A similar thing may happen to `Map` soon, but that is a significant breaking change.
- Indexing for union tag types starts at 0 now, instead of 1.
    - There were many annoyances where Zero-Is-Initialization (ZII) was not followed and
      that was causing too many bugs to be worth it.

Bugfixes:
- Numerous bugs related to polymorphic procedures
</pre>
